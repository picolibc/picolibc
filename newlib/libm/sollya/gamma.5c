real[] gamma128_coeffs = {
	/* 50 coefficients */
/*
	0x1p0 ,
	-0x1.2788cfc6fb618f49a37c7f0202a6p-1 ,
	0x1.fa658c23b15787764ad196a08943p-1 ,
	-0x1.d0a118f324b62f62d85be450d849p-1 ,
	0x1.f6a51055096b53f57c9ee773b59ep-1 ,
	-0x1.f6c80ec38b67a8d80e1ab8fa6a95p-1 ,
	0x1.fc7e0a6eb310af7dee704f09d476p-1 ,
	-0x1.fdf3f157b7a395bf459f015cb2c6p-1 ,
	0x1.ff07b5a17ff6b99202c7486cadb5p-1 ,
	-0x1.ff803d68a0bd3f8d2d7800b5fb8cp-1 ,
	0x1.ffc0841d585a2abde75ef5b72a5ep-1 ,
	-0x1.ffe018c484f47c938f494302ca6dp-1 ,
	0x1.fff00b768f1c665116b97f85f3dep-1 ,
	-0x1.fff8035584df070798c1a5259458p-1 ,
	0x1.fffc012f94cca805daa8e19d8542p-1 ,
	-0x1.fffe0062ab5173cd60867ce6480ep-1 ,
	0x1.ffff002110f798418ffa4b79e7ddp-1 ,
	-0x1.ffff8008ddb9158af2c76d629a39p-1 ,
	0x1.ffffbff079b3a356671841f86f92p-1 ,
	-0x1.ffffdf70d67a7323db8edbb3dd6bp-1 ,
	0x1.ffffec5271233146fa68c0c469acp-1 ,
	-0x1.ffffe2f09d30a441565bb36dc0cp-1 ,
	0x1.ffff9168263bc998a44387d7f708p-1 ,
	-0x1.fffe1e03efcf1ae367208e70ff94p-1 ,
	0x1.fff8728ad592bb8a672f7ec34615p-1 ,
	-0x1.ffe4b6997139df04450a290ee06cp-1 ,
	0x1.ffa726757fee92d78d0b76dff26cp-1 ,
	-0x1.fefa8e713109c04b3607cac3456p-1 ,
	0x1.fd46f2bce32f1d9ab8e21b9b349cp-1 ,
	-0x1.f967f3fc4b57b5c1f3d4c245ccddp-1 ,
	0x1.f176301dcbb42cf03297562644abp-1 ,
	-0x1.e2bf8b7276f617d654065cc45382p-1 ,
	0x1.ca28144522ab2a9e7bc0e6d2e11cp-1 ,
	-0x1.a5147ef254b51e7f76707764a218p-1 ,
	0x1.72b2905d51365e0bf191627401fdp-1 ,
	-0x1.351227d17aa105fc4bf2f4a1cb5p-1 ,
	0x1.e2ae628ca7b691498e0051354f3cp-2 ,
	-0x1.5d3a02c575bf5221088e977edf6fp-2 ,
	0x1.cf70ebfdb350e7f710d1ca6e52efp-3 ,
	-0x1.1731dee63733b46f0aa9f1527043p-3 ,
	0x1.2e5a2d0acf89c5edef8a7e0c9a2dp-4 ,
	-0x1.232d05287202ac051700e4f07426p-5 ,
	0x1.ece4ae60fab4ba6d44fc4ce1a4abp-7 ,
	-0x1.69ada0dea446b8898021b4ac2f3ap-8 ,
	0x1.c49c595bee5a64fc5304c6d3119ep-10 ,
	-0x1.d8dfddf18a189f3d639e2e11ad06p-12 ,
	0x1.90e2c3c23a94a90866b4287a58a7p-14 ,
	-0x1.08b50caa073e2e51f4e1d28e6798p-16 ,
	0x1.fe85dfa590a46171158583c64113p-20 ,
	-0x1.3f9333294c89fb96239213f1e271p-23 ,
	0x1.85a501d5d74add9951dd571906a1p-28 ,
*/
    0x1p0 ,
    -0x1.2788cfc6fb618f46p-1 ,
    0x1.fa658c23b1578254p-1 ,
    -0x1.d0a118f324b3aa3ep-1 ,
    0x1.f6a5105508c989f4p-1 ,
    -0x1.f6c80ec372ce897ep-1 ,
    0x1.fc7e0a6c32c59d56p-1 ,
    -0x1.fdf3f12950725b54p-1 ,
    0x1.ff07b31fff79de44p-1 ,
    -0x1.ff8022bd1f515118p-1 ,
    0x1.ffbfa41b1eae45a4p-1 ,
    -0x1.ffda2eee8fc360cp-1 ,
    0x1.ffcf64bfbcc0d79ep-1 ,
    -0x1.ff62de106d363db4p-1 ,
    0x1.fdc29891cef8e1dp-1 ,
    -0x1.f8d549228ab04c22p-1 ,
    0x1.ec6c411783741f9ap-1 ,
    -0x1.d238fe9f01c49214p-1 ,
    0x1.a3c917d73dca8e5p-1 ,
    -0x1.5ebf72442f96e85ep-1 ,
    0x1.08e8df67ab7c87d4p-1 ,
    -0x1.603ec88e323cd66p-2 ,
    0x1.915e6f90031df2fap-3 ,
    -0x1.7cd05e51298c535ep-4 ,
    0x1.22dd143aa682d30ep-5 ,
    -0x1.56219a3fed3533aap-7 ,
    0x1.21deb84e1a3414f6p-9 ,
    -0x1.3a1b9187f3ac4048p-12 ,
    0x1.465696f13cd90dfap-16 ,
};

real fma(a, b, c) {
	real	ap = imprecise(a, precision(a) * 2);
	real	bp = imprecise(b, precision(b) * 2);
	real	cp = imprecise(c, precision(c) * 2);

	return imprecise(ap * bp + cp, precision(a));
}

typedef struct {
	real hi, lo;
} double_real_t;

int prec = 64;

double_real_t
mul_split(real x, real y)
{
	x = imprecise(x, prec);
	y = imprecise(y, prec);

	double_real_t	d;

	d.hi = x * y;
	d.lo = fma(x, y, -d.hi);
	return d;
}

printf("%g * %g = %v\n", 2, 3, mul_split(2,3));

double_real_t
real_to_dr(real x)
{
	return (double_real_t) { .hi = x, .lo = 0 };
}

real
my_gamma128(real x)
{
	real r;
	real p;
	real eps;
	double_real_t dr;

	x = imprecise(x, prec);

	p = 1;
	eps = 0;
	while (x >= 2) {
		x -= 1;
		dr = mul_split(p, x);
		p = dr.hi;
		eps += dr.lo / p;
	}
	while (x < 1) {
		printf("mul 1/%g\n", x);
		dr = mul_split(p, 1/x);
		p = dr.hi;
		eps += dr.lo / p;
		x += 1;
	}

        int i = dim(gamma128_coeffs) - 1;
        r = imprecise(gamma128_coeffs[i], prec);
        real y = x - 1;
        while (--i >= 0)
		r = fma(y, r, imprecise(gamma128_coeffs[i], prec));

	r = r * p * (1 + eps);
	if (precision(r) != prec)
		printf("precision %d\n", precision(r));
	return r;
}

real
real_gamma(real x)
{
	int p = precision(x);
	real y = gamma(imprecise(x, 4 * p));
	return imprecise(y, p);
}

int bits(real x, int bits)
{
	real m = mantissa(x);
	real r = m * (2 ** precision(x));
	return r;
}

void main()
{
	real MIN = 0x1p-4;
	real STEP = 0x1p-4;
	real MAX = 0x1.ffffffffffffffffffffffffffffp16383;
#	real MAX = 0x1.fffffffffffffp1023;
#	real MAX = 0x1.fffffep127;

        real l, m, x;
        real mx = 0;
	real me = 0;

	printf("%g\n", my_gamma128(0x1p-127));
	exit(0);

	for (x = 10; ; x *= 2)
		if (gamma(x) > MAX)
			break;

	real a = x/2;
	real b = x;
	real c;
	while (imprecise(a, prec) < imprecise(b, prec)) {
		c = (a + b) / 2;
		if (gamma(c) > MAX)
			b = c;
		else
			a = c;
	}
	printf("max %a\n", c);

        for (x = MIN; x <= c; x += STEP) {
		real xp = imprecise(x, prec);
		l = real_gamma(xp);
		m = my_gamma128(xp);
		real e;
		if (exponent(l) != exponent(m))
			e = 1000;
		else {
			e = abs(bits(l, prec) - bits(m, prec));
		}
		if (e > me) {
			mx = x; me = e;
			printf("max error %g at %g got %a want %a\n", e, x, m, l);
		}
        }
}

main();
